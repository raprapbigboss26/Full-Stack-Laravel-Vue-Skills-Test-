import{bT as F,r as f,m as v,bS as k,bR as i}from"./index-Bx6MUOaO.js";const E=F("tasks",()=>{const r=f([]),u=f(!1),p=f(null),c=f({status:"all",priority:"all",search:""}),m=v(()=>{let e=[...r.value];if(c.value.status&&c.value.status!=="all"&&(e=e.filter(s=>s.status===c.value.status)),c.value.priority&&c.value.priority!=="all"&&(e=e.filter(s=>s.priority===c.value.priority)),c.value.search){const s=c.value.search.toLowerCase();e=e.filter(o=>o.title.toLowerCase().includes(s)||o.description.toLowerCase().includes(s))}return e.sort((s,o)=>s.order-o.order)}),T=v(()=>r.value.filter(e=>e.status==="pending")),g=v(()=>r.value.filter(e=>e.status==="completed")),h=v(()=>r.value.filter(e=>e.priority==="high")),y=v(()=>({total:r.value.length,pending:T.value.length,completed:g.value.length,high:h.value.length}));return{tasks:r,loading:u,statistics:p,filters:c,filteredTasks:m,pendingTasks:T,completedTasks:g,highPriorityTasks:h,taskCount:y,fetchTasks:async(e=!1)=>{var o,l;if(u.value&&!e)return;u.value=!0;const s=k();try{const t=await i.getTasks(c.value);r.value=t.data}catch(t){const a=((l=(o=t.response)==null?void 0:o.data)==null?void 0:l.message)||"Failed to fetch tasks";s.error(a),console.error("Fetch tasks error:",t)}finally{u.value=!1}},createTask:async e=>{var o,l;const s=k();u.value=!0;try{const t=await i.createTask(e);return r.value.push(t.data),s.success(t.message||"Task created successfully!"),t.data}catch(t){const a=((l=(o=t.response)==null?void 0:o.data)==null?void 0:l.message)||"Failed to create task";throw s.error(a),t}finally{u.value=!1}},updateTask:async(e,s)=>{var l,t;const o=k();u.value=!0;try{const a=await i.updateTask(e,s),n=r.value.findIndex(d=>d.id===e);return n!==-1&&(r.value[n]=a.data),o.success(a.message||"Task updated successfully!"),a.data}catch(a){const n=((t=(l=a.response)==null?void 0:l.data)==null?void 0:t.message)||"Failed to update task";throw o.error(n),a}finally{u.value=!1}},deleteTask:async e=>{var o,l;const s=k();u.value=!0;try{const t=await i.deleteTask(e);r.value=r.value.filter(a=>a.id!==e),s.success(t.message||"Task deleted successfully!")}catch(t){const a=((l=(o=t.response)==null?void 0:o.data)==null?void 0:l.message)||"Failed to delete task";throw s.error(a),t}finally{u.value=!1}},toggleTaskStatus:async e=>{var l,t;const s=r.value.find(a=>a.id===e);if(!s)return;const o=k();try{let a;s.status==="pending"?a=await i.completeTask(e):a=await i.markTaskPending(e);const n=r.value.findIndex(w=>w.id===e);n!==-1&&(r.value[n]=a.data);const d=a.data.status==="completed"?"completed":"pending";return o.success(`Task marked as ${d}!`),a.data}catch(a){const n=((t=(l=a.response)==null?void 0:l.data)==null?void 0:t.message)||"Failed to update task status";throw o.error(n),a}},reorderTasks:async e=>{var o,l;const s=k();try{const t=[...r.value];r.value=e.map((n,d)=>({...n,order:d+1}));const a={tasks:e.map((n,d)=>({id:n.id,order:d+1}))};await i.reorderTasks(a),s.success("Tasks reordered successfully!")}catch(t){r.value=oldTasks;const a=((l=(o=t.response)==null?void 0:o.data)==null?void 0:l.message)||"Failed to reorder tasks";throw s.error(a),t}},fetchStatistics:async()=>{try{const e=await i.getTaskStatistics();p.value=e.data}catch(e){console.error("Fetch statistics error:",e)}},setFilters:e=>{c.value={...c.value,...e}},clearFilters:()=>{c.value={status:"all",priority:"all",search:""}},getTaskById:e=>r.value.find(s=>s.id===e),addTask:e=>{r.value.push(e)},removeTask:e=>{r.value=r.value.filter(s=>s.id!==e)},updateTaskInList:e=>{const s=r.value.findIndex(o=>o.id===e.id);s!==-1&&(r.value[s]=e)},clearTasks:()=>{r.value=[],p.value=null}}});export{E as u};
